[TOC]

## 1、二维数组中的查找（223ms）

- 题目描述：

    在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。

- 思路：

    由于二维数组从左到右，从上到下都是有序依次增大，所以可以考虑，选取右上角或右下角。因为这两个位置有一个特点，都位于两边的数字中间。例如，右上角位置左侧都比其小，该位置下侧都比其大，因此挪动位置具有唯一性。左下角位置亦如此。

- 代码实现：[二维数组的查找](https://github.com/hugechuanqi/Algorithms-and-Data-Structures/blob/master/%E5%89%91%E6%8C%87offer/01.%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E6%9F%A5%E6%89%BE.py)

    

## 2、替换空格（24ms）

- 题目描述：

    请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。

- 思路：

    1.  从前往后替换，需要将空格后面所有字符的位置都后移两格，循环中嵌套判断和循环，时间复杂度为O(n*n)；

    2.  从后往前替换，只需要提前计算字符串长度和空格的数目，每个空格使得字符串多出两个长度，然后逆序替换为新的字符串。具体过程为：

        （1） 首先输入一个字符串，然后计算字符串长度和空格的数目，每个空格使得字符串多出两个长度，从而计算出新的字符串长度；

        （2） 接着从后往前开始替换，第一个指针p1放在原字符串最后一个位置，第二个指针p2放在新字符串最后一个位置，同时向前移动，每当碰到空格的时候，指针p1向前移动1格，而指针p2向前移动3格，直到两个指针指向同一个位置，表明空格替换完毕，剩余字符一一替换即可。 

- 代码实现：[替换空格](https://github.com/hugechuanqi/Algorithms-and-Data-Structures/blob/master/%E5%89%91%E6%8C%87offer/02.%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC.py)



## 3、从尾到头打印链表（22ms）

- 题目描述：

    输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。

- 思路：

    这是最后一个节点先输出，属于典型的“后进先出”，可以用栈来实现，每经过一个节点，把该节点放入到一个栈中，到遍历完整个链表的时候，再从栈顶开始逐个输出节点的值。

- 代码实现：[从尾到头打印链表](https://github.com/hugechuanqi/Algorithms-and-Data-Structures/blob/master/%E5%89%91%E6%8C%87offer/%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8.py)



## 4、重建二叉树（37ms）

- 题目描述：

    输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。

    1.  前序遍历：根节点->左子树->右子树

    2.  中序遍历：左子树->根节点->右子树

    3.  后序遍历：左子树->右子树->根节点

- 思路：

    在函数ConstructCore中，我们先根据前序遍历的第一个数字创建根结点，然后在中序遍历中找到根结点的位置，这样就能确定左右子树节点的数量。在前序遍历和中序遍历中划分了左、右子树节点的值之后，我们就可以递归地调用函数ConstructCore去分别构建它的左、右子树。

- 代码实现：[重建二叉树](https://github.com/hugechuanqi/Algorithms-and-Data-Structures/blob/master/%E5%89%91%E6%8C%87offer/04.%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91.py)



## 5、用两个栈实现队列（24ms）

- 题目描述：

    用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。

    1.  栈：常见的数据结构，后进先出，即最后被压入栈的元素会第一个被弹出。

    2.  队列：重要的数据结构，先进先出，即第一个进入队列的元素将会第一个出来。

- 思路：

    - 假设两个栈为stackA和stackB。插入元素时，先将所有元素插入到stackA中，插入元素顺序为{1,2,3,4,5}；

    - 而当我们需要删除元素时，由于需要先删除1，因此，需要借助stackB，将stackA中的所有元素逐个弹出并压入stackB；

    - 由于栈的结构是后入先出，因此这个时候栈B的元素依次为{5,4,3,2,1}，即1变成了栈顶。然后我们让栈B中的所有元素依次弹出，就可以实现先入先出，即两个栈实现一个队列。

- 流程（删除一个元素）：

    1.  当栈B不为空时，在stackB中的栈顶元素是最先进入队列的，因此可以弹出；

    2.  当栈B为空时，我们需要将stackA中的元素逐个弹出至stackB，然后再弹出stackB的栈顶元素。

- 代码实现：[两个栈实现队列](https://github.com/hugechuanqi/Algorithms-and-Data-Structures/blob/master/%E5%89%91%E6%8C%87offer/05.%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97.py)



## 17、树的子结构（27ms，5836k）

- 题目描述：

    输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）

- 思路：

    要查找A中是否存在和树B结构一样的子树，分为以下两步：

        1.  第一步：在树A中找到和树B的根结点的值一样的结点R；

        2.  第二步：判断树A中以R为根结点的子树是否包含和B一样的结构。

    遍历结点下面的子树，直到树B中的所有结点在树A中某个子树中找到。

- 代码实现：[树的子结构](https://github.com/hugechuanqi/Algorithms-and-Data-Structures/blob/master/%E5%89%91%E6%8C%87offer/17.%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84.py)



## 18、二叉树的镜像（38ms）

- 题目描述：

    操作给定的二叉树，将其变换为源二叉树的镜像。

- 思路：

    - 二叉树的镜像：即根结点和每个中间结点的左右孩子结点交换位置得到的一棵二叉树。

    - 求镜像的过程：先前序遍历这棵树的每个结点，如果遍历的结点有子结点，就交换它的两个子结点。当交换完所有非叶结点的左、右子结点之后，就得到了树的镜像。

    -  前序遍历：根节点->左子树->右子树.

- 代码实现：[二叉树的镜像](https://github.com/hugechuanqi/Algorithms-and-Data-Structures/blob/master/%E5%89%91%E6%8C%87offer/18.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F.py)

## 22、从上往下打印二叉树（50ms，5832k）

- 题目描述：

    从上往下打印出二叉树的每个节点，同层节点从左至右打印。

- 思路：

    此题属于广度优先层次遍历，利用一个队列来实现。层次遍历的基本过程是：

        - 从根结点出发（依次加入到队列中），并且从队列中取出一个元素；

        - 访问该元素所指的结点（即取出该结点的值）；

        - 若该元素所指结点的左、右孩子结点非空，则将其左、右孩子的指针顺序入队列。

- 代码实现：[从上往下打印二叉树](https://github.com/hugechuanqi/Algorithms-and-Data-Structures/blob/master/%E5%89%91%E6%8C%87offer/22.%E4%BB%8E%E4%B8%8A%E5%BE%80%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91.py)

## 24、二叉树中和为某一值的路径（26ms，5728k）

- 题目描述：

    输入一颗二叉树的根节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前)

- 思路：

    1.  首先用前序遍历的方式访问到某一个结点，我们把该结点添加到路径中，并且累加该结点对应的值。

    2.  如果该结点为叶结点，并且路径上结点的值的和刚好等于输入的整数，则当前路径符合要求。

    3.  如果该结点不是叶结点，则继续访问它的子结点。

    4.  当前结点访问结束后，递归函数将自动回到它的父结点。并且在函数退出之前要在路径上删除当前结点并减去当前结点的值，以确保返回父结点时路径刚好是从根结点到父结点。

- 代码实现：[二叉树中和为某一值的路径](https://github.com/hugechuanqi/Algorithms-and-Data-Structures/blob/master/%E5%89%91%E6%8C%87offer/24.%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84.py)



## 38、二叉树的深度（26ms，5624k）

- 题目描述：

    输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。

- 思路：

    如果一个树只有一个根结点，那它的深度为1；如果根结点只有左子树没有右子树，则在它的左子树深度上加1；同样，如果根结点只有右子树没有左子树，则在它的右子树深度上加1；如果根结点既有左子树又有右子树，则该树的深度为左右子树深度的较大值加1.最后将左右子树递归判断其是否右左右子树（即不断计算左右子树的深度）

- 代码实现：[二叉树的深度](https://github.com/hugechuanqi/Algorithms-and-Data-Structures/blob/master/%E5%89%91%E6%8C%87offer/38.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6.py)

## 39、平衡二叉树（30ms，5624k）

- 题目描述：

    输入一棵二叉树，判断该二叉树是否是平衡二叉树。

- 思路：

    - 如果某二叉树中任意结点的左、右子树的深度相差不超过1（包括根结点和中间结点），那么它就是一棵平衡二叉树。

- 代码实现：[平衡二叉树](https://github.com/hugechuanqi/Algorithms-and-Data-Structures/blob/master/%E5%89%91%E6%8C%87offer/39.%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91.py)

## 58、对称的二叉树（26ms，5704k）

- 题目描述：

    请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。

- 思路：

    - 首生成二叉树的镜像，然后判断该二叉树与二叉树的镜像的每个结点是否相等，如果完全相等，则该二叉树为对称的。

    - 将该二叉树与其本身是否对称作判断，首先，判断二叉树中的某个结点的左右孩子结点是否对称（即值是否相等），然后递归判断左结点的右孩子（左孩子）结点与右结点的左孩子（右孩子）结点是否对称。

- 代码实现：[对称的二叉树](https://github.com/hugechuanqi/Algorithms-and-Data-Structures/blob/master/%E5%89%91%E6%8C%87offer/58.%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91.py)



**参考**：

1. 《剑指offer》宝典神功

2. 牛客网：https://www.nowcoder.com/ta/coding-interviews