[TOC]

注意：如果只是为了解决当前题目中的问题，只需要关注Solution类中方法即可，其他代码是为了完整，能实现本地实现通过
----------------------------------------------------

## 1、二维数组中的查找（数组，223ms）

- 题目描述：

    在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。

- 思路：

    由于二维数组从左到右，从上到下都是有序依次增大，所以可以考虑，选取右上角或右下角。因为这两个位置有一个特点，都位于两边的数字中间。例如，右上角位置左侧都比其小，该位置下侧都比其大，因此挪动位置具有唯一性。左下角位置亦如此。

- 代码实现：[二维数组的查找](https://github.com/hugechuanqi/Algorithms-and-Data-Structures/blob/master/%E5%89%91%E6%8C%87offer/01.%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E6%9F%A5%E6%89%BE.py)

    

## 2、替换空格（字符串，24ms，5732k）

- 题目描述：

    请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。

- 思路：

    1.  从前往后替换，需要将空格后面所有字符的位置都后移两格，循环中嵌套判断和循环，时间复杂度为O(n*n)；

    2.  从后往前替换，只需要提前计算字符串长度和空格的数目，每个空格使得字符串多出两个长度，然后逆序替换为新的字符串。具体过程为：

        （1） 首先输入一个字符串，然后计算字符串长度和空格的数目，每个空格使得字符串多出两个长度，从而计算出新的字符串长度；

        （2） 接着从后往前开始替换，第一个指针p1放在原字符串最后一个位置，第二个指针p2放在新字符串最后一个位置，同时向前移动，每当碰到空格的时候，指针p1向前移动1格，而指针p2向前移动3格，直到两个指针指向同一个位置，表明空格替换完毕，剩余字符一一替换即可。 

- 代码实现：[替换空格](https://github.com/hugechuanqi/Algorithms-and-Data-Structures/blob/master/%E5%89%91%E6%8C%87offer/02.%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC.py)



## 3、从尾到头打印链表（栈，22ms）

- 题目描述：

    输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。

- 思路：

    这是最后一个节点先输出，属于典型的“后进先出”，可以用栈来实现，每经过一个节点，把该节点放入到一个栈中，到遍历完整个链表的时候，再从栈顶开始逐个输出节点的值。

- 代码实现：[从尾到头打印链表](https://github.com/hugechuanqi/Algorithms-and-Data-Structures/blob/master/%E5%89%91%E6%8C%87offer/%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8.py)



## 4、重建二叉树（二叉树，37ms）
- 重点：理清前序遍历、中序遍历、后序遍历、层序遍历的区别和构建方法（递归+非递归）

- 题目描述：

    输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中**都不含重复的数字**。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。

    1.  前序遍历：根节点->左子树->右子树

    2.  中序遍历：左子树->根节点->右子树

    3.  后序遍历：左子树->右子树->根节点

- 思路：

    在函数ConstructCore中，我们先根据前序遍历的第一个数字创建根结点，然后在中序遍历中找到根结点的位置，这样就能确定左右子树节点的数量，例如m1、m2，则前序遍历中根结点之后的m1个树就是左子树结点，再往后的m2个结点为右子树结点。在前序遍历和中序遍历中划分了左、右子树节点的值之后，我们就可以递归地调用函数ConstructCore去分别构建它的左、右子树。

- 代码实现：[重建二叉树](https://github.com/hugechuanqi/Algorithms-and-Data-Structures/blob/master/%E5%89%91%E6%8C%87offer/04.%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91.py)



## 5、用两个栈实现队列（栈与队列，24ms）

- 题目描述：

    用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。

    1.  栈：常见的数据结构，后进先出，即最后被压入栈的元素会第一个被弹出。

    2.  队列：重要的数据结构，先进先出，即第一个进入队列的元素将会第一个出来。

- 思路：

    - 假设两个栈为stackA和stackB。插入元素时，先将所有元素插入到stackA中，插入元素顺序为{1,2,3,4,5}；

    - 而当我们需要删除元素时，由于需要先删除1，因此，需要借助stackB，将stackA中的所有元素逐个弹出并压入stackB；

    - 由于栈的结构是后入先出，因此这个时候栈B的元素依次为{5,4,3,2,1}，即1变成了栈顶。然后我们让栈B中的所有元素依次弹出，就可以实现先入先出，即两个栈实现一个队列。

- 流程（删除一个元素）：

    1.  当栈B不为空时，在stackB中的栈顶元素是最先进入队列的，因此可以弹出；

    2.  当栈B为空时，我们需要将stackA中的元素逐个弹出至stackB，然后再弹出stackB的栈顶元素。

- 代码实现：[两个栈实现队列](https://github.com/hugechuanqi/Algorithms-and-Data-Structures/blob/master/%E5%89%91%E6%8C%87offer/05.%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97.py)

## 16、合并两个已经排序的链表（链表，41ms，5752k）
- 题目描述:
    输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。
- 核心：
    利用两个指针分别取值比较，中止条件为1个为空，1个不为空，之后再将不为空的剩余链表添加至融合链表后。
- 思路：
    首先建立两个指针p,q，分别指向两个链表的头节点，然后比较p,q取值大小，较小的链表节点添加到新的融合链表中，并将较小节点对应指针后移一位，指向下一个节点，较大取值节点指针不变，依次比较，直到两个指针有一个为空，然后将不为空的链表直接添加至融合链表中。
- 代码实现：


## 17、树的子结构（二叉树，27ms，5836k）

- 题目描述：

    输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）

- 思路：

    要查找A中是否存在和树B结构一样的子树，分为以下两步：

        1.  第一步：在树A中找到和树B的根结点的值一样的结点R；

        2.  第二步：判断树A中以R为根结点的子树是否包含和B一样的结构。

    遍历结点下面的子树，直到树B中的所有结点在树A中某个子树中找到。

- 代码实现：[树的子结构](https://github.com/hugechuanqi/Algorithms-and-Data-Structures/blob/master/%E5%89%91%E6%8C%87offer/17.%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84.py)



## 18、二叉树的镜像（38ms）

- 题目描述：

    操作给定的二叉树，将其变换为源二叉树的镜像。

- 思路：

    - 二叉树的镜像：即根结点和每个中间结点的左右孩子结点交换位置得到的一棵二叉树。

    - 求镜像的过程：先前序遍历这棵树的每个结点，如果遍历的结点有子结点，就交换它的两个子结点。当交换完所有非叶结点的左、右子结点之后，就得到了树的镜像。

    -  前序遍历：根节点->左子树->右子树.

- 代码实现：[二叉树的镜像](https://github.com/hugechuanqi/Algorithms-and-Data-Structures/blob/master/%E5%89%91%E6%8C%87offer/18.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F.py)

## 22、从上往下打印二叉树（50ms，5832k）

- 题目描述：

    从上往下打印出二叉树的每个节点，同层节点从左至右打印。

- 思路：

    此题属于广度优先层次遍历，利用一个队列来实现。层次遍历的基本过程是：

        - 从根结点出发（依次加入到队列中），并且从队列中取出一个元素；

        - 访问该元素所指的结点（即取出该结点的值）；

        - 若该元素所指结点的左、右孩子结点非空，则将其左、右孩子的指针顺序入队列。

- 代码实现：[从上往下打印二叉树](https://github.com/hugechuanqi/Algorithms-and-Data-Structures/blob/master/%E5%89%91%E6%8C%87offer/22.%E4%BB%8E%E4%B8%8A%E5%BE%80%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91.py)

## 23、二叉搜索树的后序遍历序列

- 题目描述：

    输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。

    - 后序遍历：左子树->右子树->根节点

- 思路：

    对于后序遍历，其最后一个元素是根节点。因此对于序列S，最后一个元素是x（也就是根），如果去掉最后一个元素的序列为T，那么T满足：T可以分成两段，前一段（左子树）小于x，后一段（右子树）大于x，且这两段子树都是合法的后序序列。 

    - 二叉搜索树：即二叉查找树、二叉排序树（可以是空树），是具有以下性质的二叉树：

        - 若左子树不空，则左子树上所有节点的值均小于它的根节点的值；

        - 若右子树不空，则右子树上所有节点的值均大于它的根节点的值；

        - 它的左右子树也分别为二叉排序树。

- 代码实现：[二叉搜索树的后序遍历序列](https://github.com/hugechuanqi/Algorithms-and-Data-Structures/blob/master/剑指offer/23.二叉搜索树的后序遍历序列.py)

## 24、二叉树中和为某一值的路径（26ms，5728k）

- 题目描述：

    输入一颗二叉树的根节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前)

- 思路：

    1.  首先用前序遍历的方式访问到某一个结点，我们把该结点添加到路径中，并且累加该结点对应的值。

    2.  如果该结点为叶结点，并且路径上结点的值的和刚好等于输入的整数，则当前路径符合要求。

    3.  如果该结点不是叶结点，则继续访问它的子结点。

    4.  当前结点访问结束后，递归函数将自动回到它的父结点。并且在函数退出之前要在路径上删除当前结点并减去当前结点的值，以确保返回父结点时路径刚好是从根结点到父结点。

- 代码实现：[二叉树中和为某一值的路径](https://github.com/hugechuanqi/Algorithms-and-Data-Structures/blob/master/%E5%89%91%E6%8C%87offer/24.%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84.py)

## 26、二叉搜索树与双向链表
- 题目描述：

    输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。

- 思路：

    1.  在二叉搜索树中，左子节点的值总是小于父节点的值，右子节点的值总是大于父节点的值。因此，在做转换成排序双向链表时，原先指向左子节点的指针调整为链表中指向前一个节点的指针，原先指向右子节点的指针调整为链表中指向后一个节点的指针。（排序双向链表转化成二叉搜索树时，反向进行即可，即链表中指向前一个节点的指针指向二叉搜索树中的左子节点，链表中后一个节点的指针指向二叉二叉搜索树中的右子节点。）

    2.  由于要求转换后的链表是排序的，因此，我们可以通过中序遍历（正好是二叉搜索树中从小到大的顺序）树中的每个节点，每次遍历到根节点时，就把树分为三部分，第一部分为根节点，第二部分为该根节点的左子树，第三部分为该根节点的右子树。然后就可以将f该根节点和其左子树的最大值节点连接起来，并且和该根节点右子树的最小节点连接起来。

    （按照中序遍历的顺序，当我们把遍历转换到根节点时，其左子树已经转换成一个排序的链表了，并且处在链表的最后一个节点是左子树最大值节点。连接上根节点后，接着就去遍历转换右子树，并把根节点和右子树中的最小值节点连接起来。）

    - 二叉搜索树：即二叉查找树、二叉排序树（可以是空树），是具有以下性质的二叉树：

        - 若左子树不空，则左子树上所有节点的值均小于它的根节点的值；

        - 若右子树不空，则右子树上所有节点的值均大于它的根节点的值；

        - 它的左右子树也分别为二叉排序树。

    - 双向链表：双向链表和单链表一样，也是由节点组成，它的每个数据节点中都有两个指针，分别指向直接后继和直接前继。从双向链表的任意一个节点开始，都可以很方便地访问它的前驱节点和后继节点。（排序双向链表是指双向链表中的值已经从小到大排序）

        ![](https://images0.cnblogs.com/blog/497634/201402/231247423393589.jpg)

- 代码实现：[二叉搜索树与双向链表](https://github.com/hugechuanqi/Algorithms-and-Data-Structures/blob/master/剑指offer/26.二叉搜索树与双向链表.py)


## 38、二叉树的深度（26ms，5624k）

- 题目描述：

    输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。

- 思路：

    如果一个树只有一个根结点，那它的深度为1；如果根结点只有左子树没有右子树，则在它的左子树深度上加1；同样，如果根结点只有右子树没有左子树，则在它的右子树深度上加1；如果根结点既有左子树又有右子树，则该树的深度为左右子树深度的较大值加1.最后将左右子树递归判断其是否右左右子树（即不断计算左右子树的深度）

- 代码实现：[二叉树的深度](https://github.com/hugechuanqi/Algorithms-and-Data-Structures/blob/master/%E5%89%91%E6%8C%87offer/38.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6.py)

## 39、平衡二叉树（30ms，5624k）

- 题目描述：

    输入一棵二叉树，判断该二叉树是否是平衡二叉树。

- 思路：

    - 如果某二叉树中任意结点的左、右子树的深度相差不超过1（包括根结点和中间结点），那么它就是一棵平衡二叉树。

- 代码实现：[平衡二叉树](https://github.com/hugechuanqi/Algorithms-and-Data-Structures/blob/master/%E5%89%91%E6%8C%87offer/39.%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91.py)

# 55、链表中环的入口节点（30ms，5836k）
- 题目描述：
    给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。
- 核心：
    1、快慢指针判断是否存在环；2、确定环的长度；3、找到环的入口节点
- 思路：
    1、首先分别定义两个快慢指针，同时从头节点出发，如果走得快的指针走到了链表的末尾（认为指向NULL），都没有追上第一个指针，则认为链表中不包含环，如果两个指针又指向了同一个节点，则认为存在环。2、当追上时，开始移动慢指针并且开始从0计数，当再次指向该位置时，则计数值为环的长度k。3、确定环的长度之后，重新开始遍历，双指针p、q指向头节点，后移q指针k步，然后同时移动p、q指针，当两个指针再次相遇时，相遇的位置则为链表中环的入口节点。
- 代码实现：

## 56、删除链表中重复的节点（28ms，5748k）
- 题目描述：
    在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1->2->3->3->4->4->5 处理后为 1->2->5
- 核心：
    1、需要判断头结点是否为重复结点，因此需要建立前一结点，其下一节点指向该结点位置；2、然后不断后移判断，若重复需要取出该值，因为很可能有多个重复值；3、注意前一结点pPre的改变（如果重复是不改变的，不重复才后移）
- 思路：
    针对题目2，因为不知道头结点是否为重复结点，因此需要新建一个前结点pPre，其下一节点指向头结点；然后建立两个指针，不断后移判断是否重复，如果不重复，则后移一位，并且pPre也后移一位，如果重复，则取出重复值，后移指针判断是否和该值一样，如果一样则继续后移，直到不一样，则pPre的下一节点指向该位置，相当于对之后的链表重复同样的删除重复结点操作。
- 代码实现：

## 58、对称的二叉树（26ms，5704k）

- 题目描述：

    请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。

- 思路：

    - 首生成二叉树的镜像，然后判断该二叉树与二叉树的镜像的每个结点是否相等，如果完全相等，则该二叉树为对称的。

    - 将该二叉树与其本身是否对称作判断，首先，判断二叉树中的某个结点的左右孩子结点是否对称（即值是否相等），然后递归判断左结点的右孩子（左孩子）结点与右结点的左孩子（右孩子）结点是否对称。

- 代码实现：[对称的二叉树](https://github.com/hugechuanqi/Algorithms-and-Data-Structures/blob/master/%E5%89%91%E6%8C%87offer/58.%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91.py)


## 65、矩阵中的路径（回溯法）
- 题目描述：
- 思路：
- 代码实现：



**参考**：

1. 《剑指offer》宝典神功

2. 牛客网：https://www.nowcoder.com/ta/coding-interviews