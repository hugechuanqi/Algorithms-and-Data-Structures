[TOC]

## 1、二维数组中的查找（223ms）

- 题目描述：

    在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。

- 思路：

    由于二维数组从左到右，从上到下都是有序依次增大，所以可以考虑，选取右上角或右下角。因为这两个位置有一个特点，都位于两边的数字中间。例如，右上角位置左侧都比其小，该位置下侧都比其大，因此挪动位置具有唯一性。左下角位置亦如此。

- 代码实现：[二维数组的查找](https://github.com/hugechuanqi/Algorithms-and-Data-Structures/blob/master/%E5%89%91%E6%8C%87offer/01.%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E6%9F%A5%E6%89%BE.py)

    

## 2、替换空格（24ms）

- 题目描述：

    请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。

- 思路：

    1.  从前往后替换，需要将空格后面所有字符的位置都后移两格，循环中嵌套判断和循环，时间复杂度为O(n*n)；

    2.  从后往前替换，只需要提前计算字符串长度和空格的数目，每个空格使得字符串多出两个长度，然后逆序替换为新的字符串。具体过程为：

        （1） 首先输入一个字符串，然后计算字符串长度和空格的数目，每个空格使得字符串多出两个长度，从而计算出新的字符串长度；

        （2） 接着从后往前开始替换，第一个指针p1放在原字符串最后一个位置，第二个指针p2放在新字符串最后一个位置，同时向前移动，每当碰到空格的时候，指针p1向前移动1格，而指针p2向前移动3格，直到两个指针指向同一个位置，表明空格替换完毕，剩余字符一一替换即可。 

- 代码实现：[替换空格](https://github.com/hugechuanqi/Algorithms-and-Data-Structures/blob/master/%E5%89%91%E6%8C%87offer/02.%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC.py)



## 3、从尾到头打印链表（22ms）

- 题目描述：

    输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。

- 思路：

    这是最后一个节点先输出，属于典型的“后进先出”，可以用栈来实现，每经过一个节点，把该节点放入到一个栈中，到遍历完整个链表的时候，再从栈顶开始逐个输出节点的值。

- 代码实现：[从尾到头打印链表](https://github.com/hugechuanqi/Algorithms-and-Data-Structures/blob/master/%E5%89%91%E6%8C%87offer/%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8.py)



## 4、重建二叉树（37ms）

- 题目描述：

    输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。

    1.  前序遍历：根节点->左子树->右子树

    2.  中序遍历：左子树->根节点->右子树

    3.  后序遍历：左子树->右子树->根节点

- 思路：

    在函数ConstructCore中，我们先根据前序遍历的第一个数字创建根结点，然后在中序遍历中找到根结点的位置，这样就能确定左右子树节点的数量。在前序遍历和中序遍历中划分了左、右子树节点的值之后，我们就可以递归地调用函数ConstructCore去分别构建它的左、右子树。

- 代码实现：[重建二叉树](https://github.com/hugechuanqi/Algorithms-and-Data-Structures/blob/master/%E5%89%91%E6%8C%87offer/04.%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91.py)



## 5、用两个栈实现队列（24ms）

- 题目描述：

    用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。

    1.  栈：常见的数据结构，后进先出，即最后被压入栈的元素会第一个被弹出。

    2.  队列：重要的数据结构，先进先出，即第一个进入队列的元素将会第一个出来。

- 思路：

    - 假设两个栈为stackA和stackB。插入元素时，先将所有元素插入到stackA中，插入元素顺序为{1,2,3,4,5}；

    - 而当我们需要删除元素时，由于需要先删除1，因此，需要借助stackB，将stackA中的所有元素逐个弹出并压入stackB；

    - 由于栈的结构是后入先出，因此这个时候栈B的元素依次为{5,4,3,2,1}，即1变成了栈顶。然后我们让栈B中的所有元素依次弹出，就可以实现先入先出，即两个栈实现一个队列。

- 流程（删除一个元素）：

    1.  当栈B不为空时，在stackB中的栈顶元素是最先进入队列的，因此可以弹出；

    2.  当栈B为空时，我们需要将stackA中的元素逐个弹出至stackB，然后再弹出stackB的栈顶元素。

- 代码实现：[两个栈实现队列](https://github.com/hugechuanqi/Algorithms-and-Data-Structures/blob/master/%E5%89%91%E6%8C%87offer/05.%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97.py)



## 17、树的子结构（27ms，5836k）

- 题目描述：

    输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）

- 思路：

    要查找A中是否存在和树B结构一样的子树，分为以下两步：

        1.  第一步：在树A中找到和树B的根结点的值一样的结点R；

        2.  第二步：判断树A中以R为根结点的子树是否包含和B一样的结构。

    遍历结点下面的子树，直到树B中的所有结点在树A中某个子树中找到。

- 代码实现：[树的子结构](https://github.com/hugechuanqi/Algorithms-and-Data-Structures/blob/master/%E5%89%91%E6%8C%87offer/17.%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84.py)



## 18、二叉树的镜像（38ms）

- 题目描述：

    操作给定的二叉树，将其变换为源二叉树的镜像。

- 思路：

    - 二叉树的镜像：即根结点和每个中间结点的左右孩子结点交换位置得到的一棵二叉树。

    - 求镜像的过程：先前序遍历这棵树的每个结点，如果遍历的结点有子结点，就交换它的两个子结点。当交换完所有非叶结点的左、右子结点之后，就得到了树的镜像。

    -  前序遍历：根节点->左子树->右子树.

- 代码实现：[二叉树的镜像](https://github.com/hugechuanqi/Algorithms-and-Data-Structures/blob/master/%E5%89%91%E6%8C%87offer/18.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F.py)



**参考**：

1. 《剑指offer》宝典神功

2. 牛客网：https://www.nowcoder.com/ta/coding-interviews