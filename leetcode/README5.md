[TOC]

## 53、最大子序和（动态规划、分治法）
- 题目描述：
    给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
- 思路：
    以数组中的每个值为起点，遍历数组，计算以该值为起点的子序的最大数值，最后对比得出以哪个值为起点的子序值最大
- 代码实现：

## 322、零钱兑换（动态规划）
- 题目描述：
    给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。
- 思路：
    假设f(n)代表要凑齐金额为n所要用的最少硬币数量，那么有：f(n) = min(f(n-c1), f(n-c2),...,f(n-cn)) + 1，其中c1,c2,...,cn为硬币的所有面额。
- 代码实现：

## 394、字符串解压（栈、深度优先搜索）
- 题目描述：
    给定一个经过编码的字符串，返回它解码后的字符串。编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。
- 思路：
    利用双栈实现，第一个栈A存储数字，另一个栈B存储两个`'['`之间的字符。首先用临时变量res表示`'['`之前的字符串，用num存储`'['`之前的数值，每当遇到`'['`时，就把res存储在栈B，将num存储至栈A，并将res赋值为''，将num赋值为''，并继续遍历改变res和num的值，每当遇到']'时，就弹出栈B和栈A的栈顶元素，将字符串不断叠加到临时变量res中，依次循环操作，直到遍历结束。
- 代码实现：
