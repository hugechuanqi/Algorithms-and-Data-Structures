[TOC]

动态规划几大问题
---------------------
（1）求最大和
（2）求最小值（零钱兑换）
（3）求方案总数（排列、组合）：排列——路径，组合——方案类型个数
（4）最长子序列（连续+非连续）：最长递增子序列，最大和子序列

## 53、最大子序和（动态规划、分治法）
- 题目描述：
    给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
- 思路：
    以数组中的每个值为起点，遍历数组，计算以该值为起点的子序的最大数值，最后对比得出以哪个值为起点的子序值最大
- 代码实现：[53最大子序和](https://github.com/hugechuanqi/Algorithms-and-Data-Structures/blob/master/leetcode/53.%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89.py)

## 100、相同的树（深度优先搜索，80ms）
- 题目描述：
    给定两个二叉树，编写一个函数来检验它们是否相同。
- 思路：
    
- 代码实现：

## 300、最长上升子序列（动态规划）
- 题目描述：给定一个无序的整数数组，找到其中最长上升子序列的长度。
- 思路：建立一个动态规划的dp数组，然后dp[i]指的就是以i位置为终点计算出来的最长上升子序列，核心内容为maxValue = max(maxValue, dp[j])，也就是如果i之前的值有比i值小时，取出i位置之前的所有dp最大值，然后+1，否则i位置的dp值为1。
- 代码实现：

## 322、零钱兑换（动态规划）
- 题目描述：
    给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。
- 思路：
    假设f(n)代表要凑齐金额为n所要用的最少硬币数量，那么有：f(n) = min(f(n-c1), f(n-c2),...,f(n-cn)) + 1，其中c1,c2,...,cn为硬币的所有面额。
- 代码实现：[322零钱兑换](https://github.com/hugechuanqi/Algorithms-and-Data-Structures/blob/master/leetcode/322.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89.py)

## 377、组合总和IV（动态规划）
- 题目描述：
- 思路：
- 代码实现：

## 394、字符串解压（栈、深度优先搜索）
- 题目描述：
    给定一个经过编码的字符串，返回它解码后的字符串。编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。
- 思路：
    利用双栈实现，第一个栈A存储数字，另一个栈B存储两个`'['`之间的字符。首先用临时变量res表示`'['`之前的字符串，用num存储`'['`之前的数值，每当遇到`'['`时，就把res存储在栈B，将num存储至栈A，并将res赋值为''，将num赋值为''，并继续遍历改变res和num的值，每当遇到']'时，就弹出栈B和栈A的栈顶元素，将字符串不断叠加到临时变量res中，依次循环操作，直到遍历结束。
- 代码实现：[394字符串解压](https://github.com/hugechuanqi/Algorithms-and-Data-Structures/blob/master/leetcode/394.%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E5%8E%8B.py)

