[TOC]

动态规划几大问题
---------------------
（1）求最大和
（2）求最小值（零钱兑换）
（3）求方案总数（排列、组合）：排列——路径，组合——方案类型个数
（4）最长子序列（连续+非连续）：最长递增子序列，最大和子序列

## 53、最大子序和（动态规划、分治法）
- 题目描述：
    给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
- 思路：
    以数组中的每个值为起点，遍历数组，计算以该值为起点的子序的最大数值，最后对比得出以哪个值为起点的子序值最大
- 代码实现：[53最大子序和](https://github.com/hugechuanqi/Algorithms-and-Data-Structures/blob/master/leetcode/53.%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89.py)

## 100、相同的树（深度优先搜索，80ms）
- 题目描述：
    给定两个二叉树，编写一个函数来检验它们是否相同。
- 思路：
    
- 代码实现：

## 300、最长上升子序列（动态规划）
- 题目描述：给定一个无序的整数数组，找到其中最长上升子序列的长度。
- 思路：建立一个动态规划的dp数组，然后dp[i]指的就是以i位置为终点计算出来的最长上升子序列，核心内容为maxValue = max(maxValue, dp[j])，也就是如果i之前的值有比i值小时，取出i位置之前的所有dp最大值，然后+1，否则i位置的dp值为1。
- 代码实现：

## 322、零钱兑换（动态规划）
- 题目描述：
    给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。
- 思路：
    假设f(n)代表要凑齐金额为n所要用的最少硬币数量，那么有：f(n) = min(f(n-c1), f(n-c2),...,f(n-cn)) + 1，其中c1,c2,...,cn为硬币的所有面额。
- 代码实现：[322零钱兑换](https://github.com/hugechuanqi/Algorithms-and-Data-Structures/blob/master/leetcode/322.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89.py)

## 377、组合总和IV（动态规划）
- 题目描述：
- 思路：
- 代码实现：

## 394、字符串解压（栈、深度优先搜索）
- 题目描述：
    给定一个经过编码的字符串，返回它解码后的字符串。编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。
- 思路：
    利用双栈实现，第一个栈A存储数字，另一个栈B存储两个`'['`之间的字符。首先用临时变量res表示`'['`之前的字符串，用num存储`'['`之前的数值，每当遇到`'['`时，就把res存储在栈B，将num存储至栈A，并将res赋值为''，将num赋值为''，并继续遍历改变res和num的值，每当遇到']'时，就弹出栈B和栈A的栈顶元素，将字符串不断叠加到临时变量res中，依次循环操作，直到遍历结束。
- 代码实现：[394字符串解压](https://github.com/hugechuanqi/Algorithms-and-Data-Structures/blob/master/leetcode/394.%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E5%8E%8B.py)

## 457、环形数组循环（数组、双指针）
- 题目描述：
    给定一个含有正整数和负整数的环形数组 nums。 如果某个索引中的数 k 为正数，则向前移动 k 个索引。相反，如果是负数 (-k)，则向后移动 k 个索引。因为数组是环形的，所以可以假设最后一个元素的下一个元素是第一个元素，而第一个元素的前一个元素是最后一个元素。确定 nums 中是否存在循环（或周期）。循环必须在相同的索引处开始和结束并且循环长度 > 1。
    此外，一个循环中的所有运动都必须沿着同一方向进行。换句话说，一个循环中不能同时包括向前的运动和向后的运动。
- 思路：
    首先，建立两个数组vistited和numSet，分别表示存储被访问过的结点和可能环形数组的结点；然后遍历所有结点，建立一个标签direction，表示当前结点的方向，一旦发生方向不同的结点，则需要将numSet置0，否则将当前结点加入至numSet，并根据当前结点判断以该结点为起点是否能构成一个环形数组（方向一直的环）。如果能就返回true，否则访问下一个结点
- 代码实现：
